# CPP笔记

## STL相关

##### std::move


std::move 是 C++11 中引入的一个函数模板，它可以将给定对象的值移动到另一个对象中，而不是进行拷贝操作。该函数模板通常用于实现移动语义，可以在某些情况下提高程序的性能。

std::move 接受一个参数，这个参数是一个左值引用。当传入的参数是一个左值时，std::move 会将该左值转化为一个右值引用，并返回该右值引用。这个过程并没有实际的拷贝操作，只是改变了左值的类型，因此可以看作是一个移动操作。

使用 std::move 可以将一个对象的所有权从一个对象转移到另一个对象，通常在以下情况下使用：

1. **移动语义**：当需要对一个对象进行移动操作时，可以使用 std::move 来避免进行不必要的拷贝操作，提高程序的性能。
2. **容器的移动操作**：当需要对容器进行移动操作时，可以使用 std::move 来避免进行不必要的拷贝操作，提高程序的性能。

需要注意的是，使用 std::move 不会对对象进行任何复制操作，也不会对对象的值进行修改。它只是将对象的值转移到另一个对象中，因此在移动之后原来的对象可能会处于未定义的状态，不能再使用它。

在实际编程中，可以使用 std::move 来实现类的移动构造函数和移动赋值运算符，以提高程序的性能。

------

移动语义和容器的移动操作是 C++11 中引入的两个重要特性，它们可以帮助程序员更高效地管理内存和对象的所有权。

移动语义指的是将对象的所有权从一个对象转移给另一个对象的操作。在 C++11 之前，所有的对象都是通过拷贝操作进行赋值和传递的，因此在需要频繁地传递和赋值对象时，会出现大量的对象拷贝，从而导致程序的性能下降。移动语义的出现解决了这个问题，通过移动对象而不是拷贝对象来实现更高效的赋值和传递操作。

具体来说，移动语义是通过右值引用来实现的。右值引用是一种特殊的引用类型，可以绑定到一个右值（临时对象或者表达式结果），表示该对象即将被销毁或不再使用，因此可以将其所有权转移给另一个对象。使用 std::move 可以将一个对象的所有权从一个对象转移到另一个对象，而不进行任何拷贝操作。

容器的移动操作是指将容器中的元素进行移动操作，而不是拷贝操作。在 C++11 中，引入了移动构造函数和移动赋值运算符来支持容器的移动操作。当使用 std::move 将一个对象移动到另一个对象时，容器会自动调用相应的移动构造函数和移动赋值运算符来将元素移动到另一个容器中，从而避免了不必要的拷贝操作，提高了程序的性能。

容器的移动操作在以下情况下特别有用：

1. 对于大型对象，移动操作比拷贝操作更高效，可以减少内存分配和释放的次数。
2. 在容器元素类型不支持拷贝操作的情况下，只能使用移动操作进行赋值和传递。

总之，移动语义和容器的移动操作是 C++11 中非常重要的特性，它们可以帮助程序员更高效地管理内存和对象的所有权，提高程序的性能。



当我们需要频繁传递和赋值一个对象时，使用移动语义可以提高程序的性能，下面是一个例子：

```cpp
class MyString {
public:
    MyString() : data_(nullptr), size_(0) {}
    MyString(const char* str) {
        size_ = strlen(str);
        data_ = new char[size_];
        memcpy(data_, str, size_);
    }
    ~MyString() {
        delete[] data_;
    }
    // 移动构造函数
    MyString(MyString&& other) {
        data_ = other.data_;
        size_ = other.size_;
        other.data_ = nullptr;
        other.size_ = 0;
    }
    // 移动赋值运算符
    MyString& operator=(MyString&& other) {
        if (this != &other) {
            delete[] data_;
            data_ = other.data_;
            size_ = other.size_;
            other.data_ = nullptr;
            other.size_ = 0;
        }
        return *this;
    }
private:
    char* data_;
    size_t size_;
};

int main() {
    MyString s1("hello");
    MyString s2(std::move(s1));  // 移动构造函数
    MyString s3;
    s3 = std::move(s2);  // 移动赋值运算符
    return 0;
}
```

在上面的代码中，我们定义了一个类 MyString，它实现了移动构造函数和移动赋值运算符。在 main 函数中，我们创建了三个 MyString 对象 s1、s2 和 s3，通过使用 std::move 将 s1 和 s2 移动到 s2 和 s3 中，避免了不必要的拷贝操作，提高了程序的性能。

容器的移动操作也非常有用，下面是一个例子：

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<std::string> vec;
    vec.push_back("hello");  // 拷贝构造函数
    vec.push_back("world");  // 拷贝构造函数
    std::vector<std::string> vec2 = std::move(vec);  // 移动构造函数
    std::cout << vec.size() << std::endl;  // 输出 0
    std::cout << vec2.size() << std::endl;  // 输出 2
    return 0;
}
```

在上面的代码中，我们创建了一个 vector 容器 vec，并向其中插入两个字符串。当我们创建 vec2 时，使用 std::move 将 vec 移动到 vec2 中，避免了拷贝操作。在移动之后，vec 的大小变为 0，而 vec2 的大小为 2。这个例子展示了如何使用容器的移动操作来避免不必要的拷贝操作，提高程序的性能。



## 杂项知识